// MARK: - UnicodeScalar extensions

// UnicodeScalar extension to classify characters
fileprivate extension UnicodeScalar {
    var isWhitespace: Bool {
        return self == " " || self == "\t" || self == "\n" || self == "\r"
    }

    var isAlpha: Bool {
        let alphaChars = Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".unicodeScalars)
        return alphaChars.contains(self)
    }

    var isNumeric: Bool {
        let numChars = Set("0123456789".unicodeScalars)
        return numChars.contains(self)
    }

    var isAlnum: Bool {
        return isAlpha || isNumeric
    }

    /// Valid identifier characters are alphanumeric or '_'
    var isIdentifier: Bool {
        return isAlnum || self == "_"
    }

    /// If the character represents a character that can occur in operators
    /// Currently includes '+', '-', '*', '/', '='
    var isOperator: Bool {
        let operatorChars = Set("+-*/=<>".unicodeScalars)
        return operatorChars.contains(self)
    }
}

// MARK: - Token

/// The diffent kinds a token generated by the lexer can have
/// - integer:
/// - identifier: An identifier
/// - `operator`: A operator
/// - leftBrace: '{'
/// - rightBrace: '}'
/// - leftParen: '('
/// - rightParen: ')'
/// - stringLiteral: A string literal
/// - endOfFile: Artificial token to represent the end of a file
public enum TokenKind: CustomStringConvertible {
    /// The 'if' keyword
    case `if`
    /// The 'else' keyword
    case `else`
    /// The 'func' keyword
    case `func`
    /// The 'return' keyword
    case `return`
    /// An integer literal
    case integer(value: Int)
    /// An identifier
    case identifier(name: String)
    /// An operator
    case `operator`(name: String)
    /// `{`
    case leftBrace
    /// `}`
    case rightBrace
    /// `(`
    case leftParen
    /// `)`
    case rightParen
    /// `:`
    case colon
    /// `->`
    case arrow
    /// ','
    case comma
    /// '_'
    case underscore
    /// A string literal
    case stringLiteral(value: String)
    /// End of file marker
    case endOfFile

    public var description: String {
        switch self {
        case .if:
            return "Keyword if"
        case .else:
            return "Keyword else"
        case .func:
            return "Keyword func"
        case .return:
            return "Keyword return"
        case .integer(let value):
            return "Integer \(value)"
        case .identifier(let name):
            return "Identifier \(name)"
        case .operator(let name):
            return "Operator \(name)"
        case .leftBrace:
            return "Left brace '{'"
        case .rightBrace:
            return "Right brace '}'"
        case .leftParen:
            return "Left paranthesis '('"
        case .rightParen:
            return "Right paranthesis ')'"
        case .colon:
            return "Colon ':'"
        case .arrow:
            return "Arrow '->'"
        case .comma:
            return "Comma ','"
        case .underscore:
            return "Underscore '_'"
        case .stringLiteral(let value):
            return "String literal \"\(value)\""
        case .endOfFile:
            return "End of file"
        }
    }

    public var sourceCodeRepresentation: String {
        switch self {
        case .if:
            return "if"
        case .else:
            return "else"
        case .func:
            return "func"
        case .return:
            return "return"
        case .integer(let value):
            return "\(value)"
        case .identifier(let name):
            return "\(name)"
        case .operator(let name):
            return "\(name)"
        case .leftBrace:
            return "{"
        case .rightBrace:
            return "}"
        case .leftParen:
            return "("
        case .rightParen:
            return ")"
        case .colon:
            return ":"
        case .arrow:
            return "->"
        case .comma:
            return ","
        case .underscore:
            return "_"
        case .stringLiteral(let value):
            return "\"\(value)\""
        case .endOfFile:
            return "End of file"
        }
    }
}

extension TokenKind: Equatable {
    public static func ==(lhs: TokenKind, rhs: TokenKind) -> Bool {
        switch (lhs, rhs) {
        case (.if, .if):
            return true
        case (.else, .else):
            return true
        case (.func, .func):
            return true
        case (.return, .return):
            return true
        case (.integer(let lhsValue), .integer(let rhsValue)) where lhsValue == rhsValue:
            return true
        case (.identifier(let lhsName), .identifier(let rhsName)) where lhsName == rhsName:
            return true
        case (.operator(let lhsName), .operator(let rhsName)) where lhsName == rhsName:
            return true
        case (.leftBrace, .leftBrace):
            return true
        case (.rightBrace, .rightBrace):
            return true
        case (.leftParen, .leftParen):
            return true
        case (.rightParen, .rightParen):
            return true
        case (.colon, .colon):
            return true
        case (.arrow, .arrow):
            return true
        case (.comma, .comma):
            return true
        case (.underscore, .underscore):
            return true
        case (.stringLiteral(let lhsValue), .stringLiteral(let rhsValue)) where lhsValue == rhsValue:
            return true
        case (.endOfFile, .endOfFile):
            return true
        default:
            return false
        }
    }
}

public func ==(token: Token, tokenKind: TokenKind) -> Bool {
    return token.payload == tokenKind
}

public func !=(token: Token, tokenKind: TokenKind) -> Bool {
    return !(token == tokenKind)
}

/// A token generated by the lexer
public struct Token {
    /// The actual payload of the token
    public let payload: TokenKind

    /// The source range where this token appeared
    public let sourceRange: SourceRange

    init(_ payload: TokenKind, sourceRange: SourceRange) {
        self.payload = payload
        self.sourceRange = sourceRange
    }
}

// MARK: - Lexer

public class Lexer {
    /// The scanner is responsible to return characters in the source code one by one and maintain
    /// the source location of these characters
    private let scanner: Scanner

    /// Create a new lexer to lex the given source code
    ///
    /// - Parameter sourceCode: The source code to lex
    public init(sourceCode: String) {
        self.scanner = Scanner(sourceCode: sourceCode)
    }

    /// Lex the next token in the source code and return it
    ///
    /// - Returns: The next token in the source code
    /// - Throws: A CompilationError if the next token could not be lexed
    public func nextToken() throws -> Token {
        while let char = scanner.currentChar, char.isWhitespace {
            scanner.consumeChar()
        }

        let directCharacterMapping: [UnicodeScalar: TokenKind] = [
            "{": .leftBrace,
            "}": .rightBrace,
            "(": .leftParen,
            ")": .rightParen,
            ":": .colon,
            ",": .comma,
            "_": .underscore,
            ]

        switch scanner.currentChar {
        case let .some(char) where char.isAlpha:
            return lexIdentifier()
        case let .some(char) where char.isNumeric:
            return lexIntegerLiteral()
        case let .some(char) where char.isOperator:
            return lexOperator()
        case let .some(char) where directCharacterMapping.keys.contains(char):
            let startLoc = scanner.sourceLoc
            scanner.consumeChar()
            return Token(directCharacterMapping[char]!, sourceRange: range(startingAt: startLoc))
        case .some("\""):
            return try lexStringLiteral()
        case nil: // End of file
            return Token(.endOfFile, sourceRange: range(startingAt: scanner.sourceLoc))
        default:
            defer {
                scanner.consumeChar()
            }
            throw CompilationError(location: scanner.sourceLoc,
                                   errorMessage: "Invalid character: '\(scanner.currentChar!)'")
        }
    }

    /// Helper method to create a source range starting at the given location and ending at the
    /// next character to be parsed
    ///
    /// - Parameter startingAt: The lcoation where the source range shall tart
    /// - Returns: A source range from the given location to the current scanner position
    private func range(startingAt: SourceLoc) -> SourceRange {
        return SourceRange(start: startingAt, end: scanner.sourceLoc)
    }

    /// Keep consuming characters while they satisfy the given condition and return the string made
    /// up from these characters
    ///
    /// - Parameter condition: Gather characters that satisfy this condition
    /// - Returns: The string made up from the characters that satisfy the given condition
    private func gatherWhile(_ condition: (UnicodeScalar) -> Bool) -> String {
        var buildupString = ""
        while let char = scanner.currentChar, condition(char) {
            buildupString.append(String(char))
            scanner.consumeChar()
        }
        return buildupString
    }

    private func lexIdentifier() -> Token {
        let startLoc = scanner.sourceLoc
        let name = gatherWhile({ $0.isIdentifier })
        let tokenKind: TokenKind
        switch name {
        case "if":
            tokenKind = .if
        case "else":
            tokenKind = .else
        case "func":
            tokenKind = .func
        case "return":
            tokenKind = .return
        default:
            tokenKind = .identifier(name: name)
        }
        return Token(tokenKind, sourceRange: range(startingAt: startLoc))
    }

    private func lexIntegerLiteral() -> Token {
        let startLoc = scanner.sourceLoc
        let value = gatherWhile({ $0.isNumeric })
        return Token(.integer(value: Int(value)!), sourceRange: range(startingAt: startLoc))
    }

    private func lexOperator() -> Token {
        let startLoc = scanner.sourceLoc
        let name = gatherWhile({ $0.isOperator })
        let tokenKind: TokenKind
        switch name {
        case "->":
            tokenKind = .arrow
        default:
            tokenKind = .operator(name: name)
        }
        return Token(tokenKind, sourceRange: range(startingAt: startLoc))
    }

    private func lexStringLiteral() throws -> Token {
        let startLoc = scanner.sourceLoc

        precondition(scanner.currentChar == "\"")
        scanner.consumeChar()
        var escapedMode = false

        var buildupString = ""

        let escapedCharacters: [UnicodeScalar: String] = [
            "t": "\t",
            "r": "\r",
            "n": "\n",
            "\\": "\\"
        ]

        while (true) {
            let sourceLoc = scanner.sourceLoc
            let nextChar = scanner.currentChar
            scanner.consumeChar()

            switch nextChar {
            case .some("\\") where !escapedMode:
                escapedMode = true
            case .some("\"") where escapedMode:
                buildupString += "\""
                escapedMode = false
            case .some("\"") where !escapedMode:
                return Token(.stringLiteral(value: buildupString), sourceRange: range(startingAt: startLoc))
            case let .some(char) where escapedMode:
                guard let unescaped = escapedCharacters[char] else {
                    throw CompilationError(location: sourceLoc, errorMessage: "Unknown escape sequence: '\\\(char)'")
                }
                buildupString += unescaped
                escapedMode = false
            case let .some(char) where !escapedMode:
                buildupString += String(char)
            case nil:
                throw CompilationError(location: sourceLoc, errorMessage: "Found end of file while scanning for string literal")
            default:
                fatalError()
            }
        }
    }
}
